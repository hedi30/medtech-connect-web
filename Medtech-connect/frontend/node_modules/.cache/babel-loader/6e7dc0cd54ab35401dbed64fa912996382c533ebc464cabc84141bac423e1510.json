{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from \"../../../internals/constants.js\";\nimport { gridVisibleColumnDefinitionsSelector } from \"../columns/gridColumnsSelector.js\";\nimport { getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { gridRenderContextSelector } from \"../virtualization/gridVirtualizationSelectors.js\";\nimport { getUnprocessedRange, isRowContextInitialized, getCellValue } from \"./gridRowSpanningUtils.js\";\nimport { GRID_CHECKBOX_SELECTION_FIELD } from \"../../../colDef/gridCheckboxSelectionColDef.js\";\nimport { useGridApiEventHandler } from \"../../utils/useGridApiEventHandler.js\";\nimport { runIf } from \"../../../utils/utils.js\";\nimport { gridPageSizeSelector } from \"../pagination/index.js\";\nimport { gridDataRowIdsSelector } from \"./gridRowsSelector.js\";\nconst EMPTY_STATE = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst skippedFields = new Set([GRID_CHECKBOX_SELECTION_FIELD, '__reorder__', GRID_DETAIL_PANEL_TOGGLE_FIELD]);\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange) => {\n  const spannedCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.spannedCells);\n  const hiddenCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCells);\n  const hiddenCellOriginMap = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);\n  if (resetState) {\n    processedRange = EMPTY_RANGE;\n  }\n  colDefs.forEach(colDef => {\n    if (skippedFields.has(colDef.field)) {\n      return;\n    }\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      const row = visibleRows[index];\n      if (hiddenCells[row.id]?.[colDef.field]) {\n        continue;\n      }\n      const cellValue = getCellValue(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        let prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && prevRowEntry && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][colDef.field] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [colDef.field]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n          prevRowEntry = visibleRows[prevIndex];\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][colDef.field] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [colDef.field]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [colDef.field]: rowSpan + 1\n          };\n        }\n      }\n    }\n    processedRange = {\n      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n    };\n  });\n  return {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap,\n    processedRange\n  };\n};\nconst getInitialRangeToProcess = (props, apiRef) => {\n  const rowCount = gridDataRowIdsSelector(apiRef).length;\n  if (props.pagination) {\n    const pageSize = gridPageSizeSelector(apiRef);\n    let paginationLastRowIndex = DEFAULT_ROWS_TO_PROCESS;\n    if (pageSize > 0) {\n      paginationLastRowIndex = pageSize - 1;\n    }\n    return {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(paginationLastRowIndex, rowCount)\n    };\n  }\n  return {\n    firstRowIndex: 0,\n    lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, rowCount)\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nexport const rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (!props.unstable_rowSpanning) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rowIds = state.rows.dataRowIds || [];\n  const orderedFields = state.columns.orderedFields || [];\n  const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n  const columnsLookup = state.columns.lookup;\n  const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean(state.filter.filterModel.quickFilterValues?.length);\n  if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rangeToProcess = getInitialRangeToProcess(props, apiRef);\n  const rows = rowIds.map(id => ({\n    id,\n    model: dataRowIdToModelLookup[id]\n  }));\n  const colDefs = orderedFields.map(field => columnsLookup[field]);\n  const {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap\n  } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);\n  return _extends({}, state, {\n    rowSpanning: {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    }\n  });\n};\nexport const useGridRowSpanning = (apiRef, props) => {\n  const processedRange = useLazyRef(() => {\n    return apiRef.current.state.rowSpanning !== EMPTY_STATE ? getInitialRangeToProcess(props, apiRef) : EMPTY_RANGE;\n  });\n  const updateRowSpanningState = React.useCallback((renderContext, resetState = false) => {\n    const {\n      range,\n      rows: visibleRows\n    } = getVisibleRows(apiRef, {\n      pagination: props.pagination,\n      paginationMode: props.paginationMode\n    });\n    if (range === null || !isRowContextInitialized(renderContext)) {\n      return;\n    }\n    if (resetState) {\n      processedRange.current = EMPTY_RANGE;\n    }\n    const rangeToProcess = getUnprocessedRange({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex + 1)\n    }, processedRange.current);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const colDefs = gridVisibleColumnDefinitionsSelector(apiRef);\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap,\n      processedRange: newProcessedRange\n    } = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange.current);\n    processedRange.current = newProcessedRange;\n    const newSpannedCellsCount = Object.keys(spannedCells).length;\n    const newHiddenCellsCount = Object.keys(hiddenCells).length;\n    const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;\n    const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;\n    const hasNoSpannedCells = newSpannedCellsCount === 0 && currentSpannedCellsCount === 0;\n    if (!shouldUpdateState || hasNoSpannedCells) {\n      return;\n    }\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowSpanning: {\n          spannedCells,\n          hiddenCells,\n          hiddenCellOriginMap\n        }\n      });\n    });\n  }, [apiRef, processedRange, props.pagination, props.paginationMode]);\n\n  // Reset events trigger a full re-computation of the row spanning state:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  const resetRowSpanningState = React.useCallback(() => {\n    const renderContext = gridRenderContextSelector(apiRef);\n    if (!isRowContextInitialized(renderContext)) {\n      return;\n    }\n    updateRowSpanningState(renderContext, true);\n  }, [apiRef, updateRowSpanningState]);\n  useGridApiEventHandler(apiRef, 'renderedRowsIntervalChange', runIf(props.unstable_rowSpanning, updateRowSpanningState));\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  useGridApiEventHandler(apiRef, 'paginationModelChange', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  useGridApiEventHandler(apiRef, 'columnsChange', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  React.useEffect(() => {\n    if (!props.unstable_rowSpanning) {\n      if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rowSpanning: EMPTY_STATE\n        }));\n      }\n    } else if (apiRef.current.state.rowSpanning === EMPTY_STATE) {\n      resetRowSpanningState();\n    }\n  }, [apiRef, resetRowSpanningState, props.unstable_rowSpanning]);\n};","map":{"version":3,"names":["_extends","React","useLazyRef","GRID_DETAIL_PANEL_TOGGLE_FIELD","gridVisibleColumnDefinitionsSelector","getVisibleRows","gridRenderContextSelector","getUnprocessedRange","isRowContextInitialized","getCellValue","GRID_CHECKBOX_SELECTION_FIELD","useGridApiEventHandler","runIf","gridPageSizeSelector","gridDataRowIdsSelector","EMPTY_STATE","spannedCells","hiddenCells","hiddenCellOriginMap","EMPTY_RANGE","firstRowIndex","lastRowIndex","skippedFields","Set","DEFAULT_ROWS_TO_PROCESS","computeRowSpanningState","apiRef","colDefs","visibleRows","range","rangeToProcess","resetState","processedRange","current","state","rowSpanning","forEach","colDef","has","field","index","row","id","cellValue","model","spannedRowId","spannedRowIndex","rowSpan","backwardsHiddenCells","prevIndex","prevRowEntry","currentRow","push","hiddenCellIndex","relativeIndex","Math","min","max","getInitialRangeToProcess","props","rowCount","length","pagination","pageSize","paginationLastRowIndex","rowSpanningStateInitializer","unstable_rowSpanning","rowIds","rows","dataRowIds","orderedFields","columns","dataRowIdToModelLookup","columnsLookup","lookup","isFilteringPending","Boolean","filter","filterModel","items","quickFilterValues","map","useGridRowSpanning","updateRowSpanningState","useCallback","renderContext","paginationMode","newProcessedRange","newSpannedCellsCount","Object","keys","newHiddenCellsCount","currentSpannedCellsCount","currentHiddenCellsCount","shouldUpdateState","hasNoSpannedCells","setState","resetRowSpanningState","useEffect"],"sources":["/home/asma/dev/medtech-connect-web/Medtech-connect/frontend/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowSpanning.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport { GRID_DETAIL_PANEL_TOGGLE_FIELD } from \"../../../internals/constants.js\";\nimport { gridVisibleColumnDefinitionsSelector } from \"../columns/gridColumnsSelector.js\";\nimport { getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { gridRenderContextSelector } from \"../virtualization/gridVirtualizationSelectors.js\";\nimport { getUnprocessedRange, isRowContextInitialized, getCellValue } from \"./gridRowSpanningUtils.js\";\nimport { GRID_CHECKBOX_SELECTION_FIELD } from \"../../../colDef/gridCheckboxSelectionColDef.js\";\nimport { useGridApiEventHandler } from \"../../utils/useGridApiEventHandler.js\";\nimport { runIf } from \"../../../utils/utils.js\";\nimport { gridPageSizeSelector } from \"../pagination/index.js\";\nimport { gridDataRowIdsSelector } from \"./gridRowsSelector.js\";\nconst EMPTY_STATE = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst skippedFields = new Set([GRID_CHECKBOX_SELECTION_FIELD, '__reorder__', GRID_DETAIL_PANEL_TOGGLE_FIELD]);\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange) => {\n  const spannedCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.spannedCells);\n  const hiddenCells = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCells);\n  const hiddenCellOriginMap = resetState ? {} : _extends({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);\n  if (resetState) {\n    processedRange = EMPTY_RANGE;\n  }\n  colDefs.forEach(colDef => {\n    if (skippedFields.has(colDef.field)) {\n      return;\n    }\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      const row = visibleRows[index];\n      if (hiddenCells[row.id]?.[colDef.field]) {\n        continue;\n      }\n      const cellValue = getCellValue(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        let prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && prevRowEntry && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][colDef.field] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [colDef.field]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n          prevRowEntry = visibleRows[prevIndex];\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][colDef.field] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [colDef.field]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [colDef.field]: rowSpan + 1\n          };\n        }\n      }\n    }\n    processedRange = {\n      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n    };\n  });\n  return {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap,\n    processedRange\n  };\n};\nconst getInitialRangeToProcess = (props, apiRef) => {\n  const rowCount = gridDataRowIdsSelector(apiRef).length;\n  if (props.pagination) {\n    const pageSize = gridPageSizeSelector(apiRef);\n    let paginationLastRowIndex = DEFAULT_ROWS_TO_PROCESS;\n    if (pageSize > 0) {\n      paginationLastRowIndex = pageSize - 1;\n    }\n    return {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(paginationLastRowIndex, rowCount)\n    };\n  }\n  return {\n    firstRowIndex: 0,\n    lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, rowCount)\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nexport const rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (!props.unstable_rowSpanning) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rowIds = state.rows.dataRowIds || [];\n  const orderedFields = state.columns.orderedFields || [];\n  const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n  const columnsLookup = state.columns.lookup;\n  const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean(state.filter.filterModel.quickFilterValues?.length);\n  if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rangeToProcess = getInitialRangeToProcess(props, apiRef);\n  const rows = rowIds.map(id => ({\n    id,\n    model: dataRowIdToModelLookup[id]\n  }));\n  const colDefs = orderedFields.map(field => columnsLookup[field]);\n  const {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap\n  } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);\n  return _extends({}, state, {\n    rowSpanning: {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    }\n  });\n};\nexport const useGridRowSpanning = (apiRef, props) => {\n  const processedRange = useLazyRef(() => {\n    return apiRef.current.state.rowSpanning !== EMPTY_STATE ? getInitialRangeToProcess(props, apiRef) : EMPTY_RANGE;\n  });\n  const updateRowSpanningState = React.useCallback((renderContext, resetState = false) => {\n    const {\n      range,\n      rows: visibleRows\n    } = getVisibleRows(apiRef, {\n      pagination: props.pagination,\n      paginationMode: props.paginationMode\n    });\n    if (range === null || !isRowContextInitialized(renderContext)) {\n      return;\n    }\n    if (resetState) {\n      processedRange.current = EMPTY_RANGE;\n    }\n    const rangeToProcess = getUnprocessedRange({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex + 1)\n    }, processedRange.current);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const colDefs = gridVisibleColumnDefinitionsSelector(apiRef);\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap,\n      processedRange: newProcessedRange\n    } = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange.current);\n    processedRange.current = newProcessedRange;\n    const newSpannedCellsCount = Object.keys(spannedCells).length;\n    const newHiddenCellsCount = Object.keys(hiddenCells).length;\n    const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;\n    const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;\n    const hasNoSpannedCells = newSpannedCellsCount === 0 && currentSpannedCellsCount === 0;\n    if (!shouldUpdateState || hasNoSpannedCells) {\n      return;\n    }\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rowSpanning: {\n          spannedCells,\n          hiddenCells,\n          hiddenCellOriginMap\n        }\n      });\n    });\n  }, [apiRef, processedRange, props.pagination, props.paginationMode]);\n\n  // Reset events trigger a full re-computation of the row spanning state:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  const resetRowSpanningState = React.useCallback(() => {\n    const renderContext = gridRenderContextSelector(apiRef);\n    if (!isRowContextInitialized(renderContext)) {\n      return;\n    }\n    updateRowSpanningState(renderContext, true);\n  }, [apiRef, updateRowSpanningState]);\n  useGridApiEventHandler(apiRef, 'renderedRowsIntervalChange', runIf(props.unstable_rowSpanning, updateRowSpanningState));\n  useGridApiEventHandler(apiRef, 'sortedRowsSet', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  useGridApiEventHandler(apiRef, 'paginationModelChange', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  useGridApiEventHandler(apiRef, 'filteredRowsSet', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  useGridApiEventHandler(apiRef, 'columnsChange', runIf(props.unstable_rowSpanning, resetRowSpanningState));\n  React.useEffect(() => {\n    if (!props.unstable_rowSpanning) {\n      if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rowSpanning: EMPTY_STATE\n        }));\n      }\n    } else if (apiRef.current.state.rowSpanning === EMPTY_STATE) {\n      resetRowSpanningState();\n    }\n  }, [apiRef, resetRowSpanningState, props.unstable_rowSpanning]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}